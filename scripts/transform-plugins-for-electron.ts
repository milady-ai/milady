#!/usr/bin/env node
/**
 * Transform dynamic plugin imports to static imports for Electron bundling.
 *
 * Dynamic imports like `import("@elizaos/plugin-sql")` cannot be bundled by
 * tsdown/rolldown because they're not statically analyzable. This script
 * transforms eliza.ts to use static imports that the bundler can inline.
 *
 * Usage: bun run scripts/transform-plugins-for-electron.ts
 *
 * This script is intended to be run during the Electron release build,
 * NOT during normal development or testing.
 */

import fs from "node:fs";
import path from "node:path";

const ELIZA_PATH = path.join(
  import.meta.dirname,
  "..",
  "src",
  "runtime",
  "eliza.ts",
);

// Read plugins from package.json - only include plugins that are actually installed
const PACKAGE_JSON_PATH = path.join(import.meta.dirname, "..", "package.json");
const packageJson = JSON.parse(fs.readFileSync(PACKAGE_JSON_PATH, "utf-8"));
const allDeps = {
  ...packageJson.dependencies,
  ...packageJson.devDependencies,
};

// Get plugins that are both in package.json AND have a valid dist folder
const NODE_MODULES = path.join(import.meta.dirname, "..", "node_modules");
const allPlugins = Object.keys(allDeps).filter((dep) =>
  dep.startsWith("@elizaos/plugin-"),
);

// Filter out plugins with broken/missing dist folders
const PLUGINS = allPlugins.filter((pkg) => {
  const distPath = path.join(NODE_MODULES, pkg, "dist");
  try {
    const stats = fs.statSync(distPath);
    return stats.isDirectory();
  } catch {
    console.log(`  Skipping ${pkg} - missing dist folder (broken package)`);
    return false;
  }
});

console.log(
  `Found ${allPlugins.length} plugins in package.json, ${PLUGINS.length} have valid dist`,
);

function pluginToVarName(pkg: string): string {
  // @elizaos/plugin-sql -> pluginSql
  // @elizaos/plugin-local-embedding -> pluginLocalEmbedding
  return pkg
    .replace("@elizaos/plugin-", "plugin")
    .replace(/-([a-z])/g, (_, c) => c.toUpperCase());
}

function generateStaticImports(): string {
  const lines = [
    "// ---------------------------------------------------------------------------",
    "// AUTO-GENERATED: Static plugin imports for Electron bundling",
    "// This section is generated by scripts/transform-plugins-for-electron.ts",
    "// ---------------------------------------------------------------------------",
  ];

  for (const pkg of PLUGINS) {
    const varName = pluginToVarName(pkg);
    lines.push(`import * as ${varName} from "${pkg}";`);
  }

  lines.push("");
  lines.push("const BUNDLED_PLUGINS: Record<string, unknown> = {");
  for (const pkg of PLUGINS) {
    const varName = pluginToVarName(pkg);
    lines.push(`  "${pkg}": ${varName},`);
  }
  lines.push("};");
  lines.push("");

  return lines.join("\n");
}

function generateResolveFunction(): string {
  return `
/**
 * Resolve a plugin from the bundled static imports.
 * In the Electron build, all plugins are bundled statically.
 */
async function resolveStaticElizaPlugin(
  pluginName: string,
): Promise<unknown | null> {
  return BUNDLED_PLUGINS[pluginName] ?? null;
}
`.trim();
}

function transformElizaFile(): void {
  console.log("Reading eliza.ts...");
  let content = fs.readFileSync(ELIZA_PATH, "utf-8");

  // Check if already transformed (idempotent check)
  // The file is considered already transformed if it has BUNDLED_PLUGINS or
  // if it has static STATIC_ELIZA_PLUGINS with a synchronous function
  if (content.includes("const BUNDLED_PLUGINS:")) {
    console.log("File already has BUNDLED_PLUGINS - already transformed, skipping.");
    return;
  }

  // Also check for the manual static imports pattern (from our previous refactor)
  if (
    content.includes("const STATIC_ELIZA_PLUGINS:") &&
    content.includes("function resolveStaticElizaPlugin(pluginName: string): unknown | null")
  ) {
    console.log("File already has static STATIC_ELIZA_PLUGINS with sync function - already transformed, skipping.");
    return;
  }

  // Find the location to insert static imports (after the last import from @elizaos/core)
  const coreImportMatch = content.match(/from "@elizaos\/core";/);
  if (!coreImportMatch) {
    throw new Error("Could not find @elizaos/core import in eliza.ts");
  }

  const insertPos =
    content.indexOf(coreImportMatch[0]) + coreImportMatch[0].length;

  // Generate static imports
  const staticImports = generateStaticImports();

  // Insert static imports after the @elizaos/core import
  content =
    content.slice(0, insertPos) +
    "\n\n" +
    staticImports +
    content.slice(insertPos);

  // Find and replace the resolveStaticElizaPlugin function (async version)
  const funcStartPattern = new RegExp(
    "async function resolveStaticElizaPlugin\\(\\s*" +
      "pluginName: string,?\\s*\\):\\s*" +
      "Promise<unknown \\| null>\\s*\\{",
  );
  const funcStartMatch = content.match(funcStartPattern);

  if (!funcStartMatch) {
    // Try sync pattern as fallback (from manual refactoring)
    console.log("No async resolveStaticElizaPlugin found - checking for sync version...");
    const syncPattern = /function resolveStaticElizaPlugin\(\s*pluginName: string\s*\):\s*unknown \| null\s*\{/;
    if (syncPattern.test(content)) {
      console.log("Found sync resolveStaticElizaPlugin - file was manually refactored, skipping function replacement.");
      // Just write the static imports we added
      console.log("Writing transformed eliza.ts with additional static imports...");
      fs.writeFileSync(ELIZA_PATH, content);
      console.log("Done! Added BUNDLED_PLUGINS to eliza.ts.");
      return;
    }
    throw new Error("Could not find resolveStaticElizaPlugin function (neither async nor sync version)");
  }

  const funcStart = content.indexOf(funcStartMatch[0]);

  // Find the matching closing brace by counting braces
  let braceCount = 0;
  let funcEnd = funcStart;
  let foundOpenBrace = false;

  for (let i = funcStart; i < content.length; i++) {
    if (content[i] === "{") {
      braceCount++;
      foundOpenBrace = true;
    } else if (content[i] === "}") {
      braceCount--;
      if (foundOpenBrace && braceCount === 0) {
        funcEnd = i + 1;
        break;
      }
    }
  }

  // Replace the function
  const newFunc = generateResolveFunction();
  content = content.slice(0, funcStart) + newFunc + content.slice(funcEnd);

  // Write the transformed file
  console.log("Writing transformed eliza.ts...");
  fs.writeFileSync(ELIZA_PATH, content);
  console.log("Done! eliza.ts has been transformed for Electron bundling.");
}

// Run the transformation
transformElizaFile();
